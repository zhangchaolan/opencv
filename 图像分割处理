import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt 
image=cv.imread("C:/111/polar.png",0)
#image1=cv.cvtColor(image,cv.COLOR_RGB2GRAY)
#距离变换函数确定前景
ret,thresh=cv.threshold(image1,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)#QTSU阈值处理
kernel=np.ones((3,3),np.uint8)#构建矩形结构元
image1Open=cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel,iterations=2)#开运算
dilate=cv.dilate(image1Open,kernel,iterations=2)#膨胀
distanceTransform=cv.distanceTransform(image1Open,cv.DIST_L2,5)#计算欧式距离
ret,fore=cv.threshold(distanceTransform,0.4*distanceTransform.max(),255,0)#对距离图像进行阈值处理
fore=np.uint8(fore)#调整处理结果
un=cv.subtract(dilate,fore)#确定未知区域
cv.imshow("image1",image1)
cv.imshow("image1Open",image1Open)
cv.imshow("distanceTransform",distanceTransform)
cv.imshow("fore",fore)
cv.imshow("dilate",dilate)
cv.imshow("un",un)
cv.waitKey()
cv.destroyAllWindows()
#确定未知区域
ret,thresh=cv.threshold(image1,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)#QTSU阈值处理
kernel=np.ones((3,3),np.uint8)#构建矩形结构元
image1Open=cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel,iterations=2)#开运算
dilate=cv.dilate(image1Open,kernel,iterations=2)#膨胀，获得背景信息
distanceTransform=cv.distanceTransform(image1Open,cv.DIST_L2,5)#计算欧式距离
ret,fore=cv.threshold(distanceTransform,0.4*distanceTransform.max(),255,0)#对距离图像进行阈值处理
fore=np.uint8(fore)#调整处理结果
un=cv.subtract(dilate,fore)#确定未知区域
cv.imshow("image1",image1)
cv.imshow("image1Open",image1Open)
cv.imshow("distanceTransform",distanceTransform)
cv.imshow("fore",fore)
cv.imshow("dilate",dilate)
cv.imshow("un",un)
cv.waitKey()
cv.destroyAllWindows()
#图像标注
ret,thresh=cv.threshold(image1,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)#QTSU阈值处理
kernel=np.ones((3,3),np.uint8)#构建矩形结构元
image1Open=cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel,iterations=2)#开运算
dilate=cv.dilate(image1Open,kernel,iterations=2)#膨胀，获得背景信息
distanceTransform=cv.distanceTransform(image1Open,cv.DIST_L2,5)#计算欧式距离
ret,fore=cv.threshold(distanceTransform,0.4*distanceTransform.max(),255,0)#对距离图像进行阈值处理
fore=np.uint8(fore)#调整处理结果
ret,labels=cv.connectedComponents(fore)#对阈值处理结果进行标注
print(ret)
plt.subplot(121)
plt.imshow(fore)
#plt.axis('off')
plt.subplot(122)
plt.imshow(labels)
#plt.axis('off')
plt.show()
#分水岭分割
ret,thresh=cv.threshold(image1,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)#QTSU阈值处理
kernel=np.ones((3,3),np.uint8)#构建矩形结构元
image1Open=cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel,iterations=2)#开运算
dilate=cv.dilate(image1Open,kernel,iterations=2)#膨胀，获得背景信息
distanceTransform=cv.distanceTransform(image1Open,cv.DIST_L2,5)#计算欧式距离
ret,fore=cv.threshold(distanceTransform,0.4*distanceTransform.max(),255,0)#对距离图像进行阈值处理
fore=np.uint8(fore)#调整处理结果
#unkonw=cv.subtract(distanceTransform,fore)#确定未知区域
ret,labels=cv.connectedComponents(fore)#对阈值处理结果进行标注
img=cv.watershed(image,labels)#分水岭操作
print(ret)
plt.subplot(121)
plt.imshow(image1)
#plt.axis('off')
plt.subplot(122)
plt.imshow(img)
#plt.axis('off')
plt.show()
#高斯金字塔向下采样
img=cv.pyrDown(image1)
img1=cv.pyrDown(img)
img2=cv.pyrDown(img1)
cv.imshow("image1",image1)
cv.imshow("img",img)
cv.imshow("img1",img1)
cv.imshow("img2",img2)
print("image1.shape",image1.shape)
print("img.shape",img.shape)
print("img1.shape",img1.shape)
print("img2.shape",img2.shape)
cv.waitKey()
cv.destroyAllWindows()
#高斯金字塔，向上采样
img=cv.pyrUp(image1)
img1=cv.pyrUp(img)
img2=cv.pyrUp(img1)
cv.imshow("image1",image1)
cv.imshow("img",img)
cv.imshow("img1",img1)
cv.imshow("img2",img2)
print("image1.shape",image1.shape)
print("img.shape",img.shape)
print("img1.shape",img1.shape)
print("img2.shape",img2.shape)
cv.waitKey()
cv.destroyAllWindows()
#拉普拉斯金字塔是本层与上一层高斯的差,为了获取丢失信息
img1=cv.pyrDown(image)
img2=cv.pyrDown(img1)
img3=cv.pyrDown(img2)
I0=image-cv.pyrUp(img1)
I1=img1-cv.pyrUp(img2)
I2=img2-cv.pyrUp(img3)
cv.imshow("image",image)
cv.imshow("I0",I0)
cv.imshow("I1",I1)
cv.imshow("I2",I2)
#print("image1.shape",image1.shape)
#print("img.shape",img.shape)
#print("img1.shape",img1.shape)
#print("img2.shape",img2.shape)
cv.waitKey()
cv.destroyAllWindows()
#用金字塔算法实现图像的分割与复原
img1=cv.pyrDown(image)
img2=cv.pyrDown(img1)
img3=cv.pyrDown(img2)
I0=image-cv.pyrUp(img1)
I1=img1-cv.pyrUp(img2)
I2=img2-cv.pyrUp(img3)
M0=cv.pyrUp(img1)+I0
M1=cv.pyrUp(img2)+I1
M2=cv.pyrUp(img3)+I2
cv.imshow("image",image)
cv.imshow("M0",M0)
cv.imshow("M1",M1)
cv.imshow("M2",M2)
print("image.shape",image.shape)
print("img1.shape",img1.shape)
print("img2.shape",img2.shape)
print("img3.shape",img3.shape)
cv.waitKey()
cv.destroyAllWindows()
